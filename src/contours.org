#+SETUPFILE setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingndarraycontours][Namespace: thi.ng.ndarray.contours]]
     - [[#level-crossings][Level crossings]]
         - [[#examples][Examples]]
         - [[#implementation][Implementation]]
     - [[#2d-contour-extraction][2D contour extraction]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.ndarray.contours

** Level crossings

This section contains high level operations to find level crossings in
1D, 2D and 3D ndarrays. The functions all take an ndarray and contour
level value and assume the array to be in major shape order (the
default order), i.e. in 2D row-major (YX), in 3D slice-row-major
(ZYX). The functions return interpolated grid positions where the
given contour level is crossed between cells.

*** Examples

#+BEGIN_SRC clojure
  (level-crossings1d (nd/ndarray :float32 [0 0 1 0]) 4 0.25)
  ;; (1.25 2.75)

  (let [a [0 0 0
           0 1 0
           0 0 0]
        a (nd/ndarray :float32 a [3 3])]
    {:x   (level-crossings2d-x a 0.25)
     :y   (level-crossings2d-y a 0.25)
     :all (level-crossings2d a 0.25)})
  ;; {:x ([1 0.25] [1 1.75])
  ;;  :y ([0.25 1] [1.75 1])
  ;;  :all ([1 0.25] [1 1.75] [0.25 1] [1.75 1])}

  (let [a (nd/ndarray :float32 (float-array 27) [3 3 3])]
    (nd/set-at a 1 1 1 1)
    {:x (level-crossings3d-x a 0.25)
     :y (level-crossings3d-y a 0.25)
     :z (level-crossings3d-z a 0.25)
     :all (level-crossings3d a 0.25)})
  ;; {:x ((1 1 0.25) (1 1 1.75))
  ;;  :y ((1 0.25 1) (1 1.75 1))
  ;;  :z ([0.25 1 1] [1.75 1 1])
  ;;  :all ((1 1 0.25) (1 1 1.75) (1 0.25 1) (1 1.75 1) [0.25 1 1] [1.75 1 1])}
#+END_SRC

*** Implementation

#+BEGIN_SRC clojure :noweb-ref level-crossings
  (defn level-crossing
    [offset a b level]
    (let [da (- a level)
          db (- b level)]
      (if-not (= (>= da 0.0) (>= db 0.0))
        (+ offset (+ 0.5 (* 0.5 (/ (+ da db) (- da db))))))))

  (defn level-crossings1d
    [mat shape level]
    (for [x (range (dec (if (number? shape) shape (first shape))))
          :let [x' (level-crossing x (nd/get-at mat x) (nd/get-at mat (inc x)) level)]
          :when x']
      x'))

  (defn level-crossings2d-x
    ([mat level]
     (level-crossings2d-x mat (nd/shape mat) level))
    ([mat [sy sx] level]
     (mapcat
      (fn [y] (map #(vector y %) (level-crossings1d (nd/pick mat y nil) sx level)))
      (range sy))))

  (defn level-crossings2d-y
    ([mat level]
     (level-crossings2d-y mat (nd/shape mat) level))
    ([mat [sy sx] level]
     (mapcat
      (fn [x] (map #(vector % x) (level-crossings1d (nd/pick mat nil x) sy level)))
      (range sx))))

  (defn level-crossings2d
    ([mat level]
     (level-crossings2d mat (nd/shape mat) level))
    ([mat shape level]
     (concat
      (level-crossings2d-x mat shape level)
      (level-crossings2d-y mat shape level))))

  (defn level-crossings3d-x
    ([mat level]
     (level-crossings3d-x mat (nd/shape mat) level))
    ([mat [sz sy sx] level]
     (mapcat
      (fn [z] (map #(cons z %) (level-crossings2d-x (nd/pick mat z nil nil) [sy sx] level)))
      (range sz))))

  (defn level-crossings3d-y
    ([mat level]
     (level-crossings3d-y mat (nd/shape mat) level))
    ([mat [sz sy sx] level]
     (mapcat
      (fn [z] (map #(cons z %) (level-crossings2d-y (nd/pick mat z nil nil) [sy sx] level)))
      (range sz))))

  (defn level-crossings3d-z
    ([mat level]
     (level-crossings3d-z mat (nd/shape mat) level))
    ([mat [sz sy sx] level]
     (mapcat
      (fn [x] (map #(conj % x) (level-crossings2d-y (nd/pick mat nil nil x) [sz sy] level)))
      (range sx))))

  (defn level-crossings3d
    ([mat level]
     (level-crossings3d mat (nd/shape mat) level))
    ([mat shape level]
     (concat
      (level-crossings3d-x mat shape level)
      (level-crossings3d-y mat shape level)
      (level-crossings3d-z mat shape level))))
#+END_SRC

** 2D contour extraction

#+BEGIN_SRC clojure :noweb-ref contours2d
  (def edge-index
    [nil [2 0] [1 0] [1 0]
     [0 0] nil [0 0] [0 0]
     [3 0] [2 0] nil [1 0]
     [3 0] [2 0] [3 0] nil])

  (def next-edges
    [[-1 0] [0 1] [1 0] [0 -1]])

  (defn set-border2d
    [mat x]
    (let [[h w] (nd/shape mat)
          h' (dec h)
          w' (dec w)
          l  (nd/pick mat nil 0)
          r  (nd/pick mat nil w')
          t  (nd/pick mat 0 nil)
          b  (nd/pick mat h' nil)]
      (loop [i w']
        (when (>= i 0)
          (nd/set-at t i x)
          (nd/set-at b i x)
          (recur (dec i))))
      (loop [i h']
        (when (>= i 0)
          (nd/set-at l i x)
          (nd/set-at r i x)
          (recur (dec i))))
      mat))

  (defn encode-crossings2d
    [src isoval]
    (let [out  (nd/ndarray :int8 (byte-array (nd/size src)) (nd/shape src))
          iso? (fn [y x m] (if (< (nd/get-at src y x) isoval) m 0))]
      (loop [pos (nd/position-seq (nd/truncate-h src -1 -1))]
        (if pos
          (let [[y x] (first pos)
                x' (inc x)
                y' (inc y)]
            (nd/set-at
             out y x
             (-> (iso? y x 0x08)
                 (bit-or (iso? y  x' 0x04))
                 (bit-or (iso? y' x' 0x02))
                 (bit-or (iso? y' x  0x01))))
            (recur (next pos)))
          out))))

  (defn mean-cell-value2d
    [src y x]
    (* (+ (+ (nd/get-at src y x) (nd/get-at src y (inc x)))
          (+ (nd/get-at src (inc y) x) (nd/get-at src (inc y) (inc x))))
       0.25))

  (defn process-saddle5
    [src y x iso from]
    (if (> (mean-cell-value2d src y x) iso)
      (if (= 3 from) [2 0x04] [0 0x01])
      (if (= 3 from) [0 0x0d] [2 0x07])))

  (defn process-saddle10
    [src y x iso from]
    (if (> (mean-cell-value2d src y x) iso)
      (if (= 0 from) [3 0x02] [1 0x08])
      (if (= 2 from) [3 0x0b] [1 0x0e])))

  (defn process-cell2d
    [src code y x iso from]
    (case (int code)
      5 (process-saddle5 src y x iso from)
      10 (process-saddle10 src y x iso from)
      (edge-index (int code))))

  (defn mix2d
    [src y1 x1 y2 x2 iso]
    (let [a (nd/get-at src y1 x1)
          b (nd/get-at src y2 x2)]
      (if (== a b) 0 (/ (- a iso) (- a b)))))

  (defn contour-vertex2d
    [src y x to iso]
    (let [x' (inc x) y' (inc y)]
      (case (int to)
        0 [y (+ x (mix2d src y x y x' iso))]
        1 [(+ y (mix2d src y x' y' x' iso)) x']
        2 [y' (+ x (mix2d src y' x y' x' iso))]
        3 [(+ y (mix2d src y x y' x iso)) x]
        nil)))

  (defn get-contours2d
    [src isoval]
    (let [[h' w']  (map dec (nd/shape src))
          coded    (encode-crossings2d src isoval)
          contours (volatile! [])]
      (loop [pos  (nd/position-seq coded)
             curr []
             to   nil
             p    nil]
        (if pos
          (let [from to
                [y x] (if p p (first pos))]
            (if (or (>= x w') (>= y h'))
              (recur (next pos) curr to nil)
              (let [id         (nd/get-at coded y x)
                    [to clear] (process-cell2d src id y x isoval from)
                    curr       (if (and (nil? from) to (seq curr))
                                 (do (vswap! contours conj curr) [])
                                 curr)]
                (when clear
                  (nd/set-at coded y x clear))
                (if (and to (>= to 0))
                  (let [vertex  (contour-vertex2d src y x to isoval)
                        [oy ox] (next-edges to)]
                    (recur (next pos) (conj curr vertex) to [(+ y oy) (+ x ox)]))
                  (recur (next pos) curr to nil)))))
          (conj @contours curr)))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/ndarray/contours.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.ndarray.contours
    (:require
     [thi.ng.ndarray.core :as nd]))

  <<level-crossings>>

  <<contours2d>>
#+END_SRC

#+BEGIN_SRC clojure
  (require
   '[thi.ng.ndarray.core :as nd]
   '[thi.ng.ndarray.contours :as c])

  (def a (nd/ndarray :float32 (float-array (* 33 33)) [33 33]))

  (dorun
   (for [[y x] (nd/position-seq a)
         :let [dx (- 16 x)
               dy (- 16 y)
               t (Math/atan2 dy dx)
               d (Math/sqrt (* (Math/sin (* t 4)) (+ (* dx dx) (* dy dy))))]]
     (nd/set-at a x y d)))

  (c/get-contours2d a 15)
#+END_SRC
