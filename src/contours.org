#+SETUPFILE setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingndarraycontours][Namespace: thi.ng.ndarray.contours]]
     - [[#level-crossings][Level crossings]]
         - [[#examples][Examples]]
         - [[#implementation][Implementation]]
     - [[#2d-contour-extraction][2D contour extraction]]
         - [[#examples][Examples]]
         - [[#implementation][Implementation]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.ndarray.contours

** Level crossings

This section contains high level operations to find level crossings in
1D, 2D and 3D ndarrays. The functions all take an ndarray and contour
level value and assume the array to be in major shape order (the
default order), i.e. in 2D row-major (YX), in 3D slice-row-major
(ZYX). The functions return interpolated grid positions where the
given contour level is crossed between cells.

*** Examples

#+BEGIN_SRC clojure
  (level-crossings1d (nd/ndarray :float32 [0 0 1 0]) 4 0.25)
  ;; (1.25 2.75)

  (let [a [0 0 0
           0 1 0
           0 0 0]
        a (nd/ndarray :float32 a [3 3])]
    {:x   (level-crossings2d-x a 0.25)
     :y   (level-crossings2d-y a 0.25)
     :all (level-crossings2d a 0.25)})
  ;; {:x ([1 0.25] [1 1.75])
  ;;  :y ([0.25 1] [1.75 1])
  ;;  :all ([1 0.25] [1 1.75] [0.25 1] [1.75 1])}

  (let [a (nd/ndarray :float32 (float-array 27) [3 3 3])]
    (nd/set-at a 1 1 1 1)
    {:x (level-crossings3d-x a 0.25)
     :y (level-crossings3d-y a 0.25)
     :z (level-crossings3d-z a 0.25)
     :all (level-crossings3d a 0.25)})
  ;; {:x ((1 1 0.25) (1 1 1.75))
  ;;  :y ((1 0.25 1) (1 1.75 1))
  ;;  :z ([0.25 1 1] [1.75 1 1])
  ;;  :all ((1 1 0.25) (1 1 1.75) (1 0.25 1) (1 1.75 1) [0.25 1 1] [1.75 1 1])}
#+END_SRC

*** Implementation

#+BEGIN_SRC clojure :noweb-ref level-crossings
  (defn level-crossing
    [offset a b level]
    (let [da (- a level)
          db (- b level)]
      (if-not (= (>= da 0.0) (>= db 0.0))
        (+ offset (+ 0.5 (* 0.5 (/ (+ da db) (- da db))))))))

  (defn level-crossings1d
    [mat shape level]
    (for [x (range (dec (if (number? shape) shape (first shape))))
          :let [x' (level-crossing x (nd/get-at mat x) (nd/get-at mat (inc x)) level)]
          :when x']
      x'))

  (defn level-crossings2d-x
    ([mat level]
     (level-crossings2d-x mat (nd/shape mat) level))
    ([mat [sy sx] level]
     (mapcat
      (fn [y] (map #(vector y %) (level-crossings1d (nd/pick mat y nil) sx level)))
      (range sy))))

  (defn level-crossings2d-y
    ([mat level]
     (level-crossings2d-y mat (nd/shape mat) level))
    ([mat [sy sx] level]
     (mapcat
      (fn [x] (map #(vector % x) (level-crossings1d (nd/pick mat nil x) sy level)))
      (range sx))))

  (defn level-crossings2d
    ([mat level]
     (level-crossings2d mat (nd/shape mat) level))
    ([mat shape level]
     (concat
      (level-crossings2d-x mat shape level)
      (level-crossings2d-y mat shape level))))

  (defn level-crossings3d-x
    ([mat level]
     (level-crossings3d-x mat (nd/shape mat) level))
    ([mat [sz sy sx] level]
     (mapcat
      (fn [z] (map #(cons z %) (level-crossings2d-x (nd/pick mat z nil nil) [sy sx] level)))
      (range sz))))

  (defn level-crossings3d-y
    ([mat level]
     (level-crossings3d-y mat (nd/shape mat) level))
    ([mat [sz sy sx] level]
     (mapcat
      (fn [z] (map #(cons z %) (level-crossings2d-y (nd/pick mat z nil nil) [sy sx] level)))
      (range sz))))

  (defn level-crossings3d-z
    ([mat level]
     (level-crossings3d-z mat (nd/shape mat) level))
    ([mat [sz sy sx] level]
     (mapcat
      (fn [x] (map #(conj % x) (level-crossings2d-y (nd/pick mat nil nil x) [sz sy] level)))
      (range sx))))

  (defn level-crossings3d
    ([mat level]
     (level-crossings3d mat (nd/shape mat) level))
    ([mat shape level]
     (concat
      (level-crossings3d-x mat shape level)
      (level-crossings3d-y mat shape level)
      (level-crossings3d-z mat shape level))))
#+END_SRC

** 2D contour extraction
*** Examples

The following demo utilizes thi.ng/geom, thi.ng/math and thi.ng/color
libs to create SVG based contour maps of generated dummy data. To try
it out yourself, simply add the following dependency (in addition to
this (ndarray) library) - geom itself depends on math & color so they
don't need to be specified in your project:

#+BEGIN_SRC clojure
  [thi.ng/geom "0.0.815"]
#+END_SRC

These images were generated with the demo code below and show the
impact of different matrix resolutions on the precision and quality of
the resulting visualizations.

**** Simplex noise

| [[../assets/noise-res32.jpg]] | [[../assets/noise-res64.jpg]] | [[../assets/noise-res128.jpg]] |
| 32 x 32                   | 64 x 64                   | 128 x 128                 |

**** Radial distance (modulated)

| [[../assets/circle-res32.jpg]] | [[../assets/circle-res64.jpg]] | [[../assets/circle-res128.jpg]] |
| 32 x 32                    | 64 x 64                    | 128 x 128                   |

**** Demo code

#+BEGIN_SRC clojure
  (require
   '[thi.ng.ndarray.core :as nd]
   '[thi.ng.ndarray.contours :as contours]
   '[thi.ng.geom.core :as g]
   '[thi.ng.geom.core.vector :as v]
   '[thi.ng.geom.svg.core :as svg]
   '[thi.ng.math.core :as m]
   '[thi.ng.math.simplexnoise :as n]
   '[thi.ng.color.core :as col])

  (defn make-palette
    "Cosine based RGB palette generation method by iq: http://v.gd/B2aySt"
    [a b c d n]
    (mapv
     #(mapv
       (fn [a b c d]
         (+ a (* b (Math/cos (* m/TWO_PI (+ (* c %) d))))))
       a b c d)
     (m/norm-range n)))

  (defn contour->svg
    "Takes a single seq of contour coordinates and converts it into an
    SVG polygon (hiccup format)."
    [contour]
    (-> (map #(-> % v/vec2 v/yx (g/scale scale)) contour)
        (svg/polygon)))

  (defn noise-matrix
    "Creates a new 2D matrix of size res and populates it with simplex
    noise, then sets border cells to 1.0 and returns matrix"
    [res ns]
    (let [mat (nd/ndarray :float32 (float-array (* res res)) [res res])]
      (dorun
       (for [[y x] (nd/position-seq mat)]
         (nd/set-at mat x y (+ 0.5 (* 0.5 (n/noise2 (+ 101 (* x ns)) (* y ns)))))))
      (contours/set-border2d mat 1)))

  (defn circle-matrix
    "Creates new 2D matrix of size res and populates it w/ modulated
    normalized distance values from center. `spikes` arg is number of
    oscillations used to modulate. `amp` is modulation strength. Sets
    border cells to 1.0 and returns matrix."
    [res spikes amp]
    (let [mat (nd/ndarray :float32 (float-array (* res res)) [res res])
          c (/ res 2.0)
          dmax (* m/SQRT2 0.5 res)]
      (dorun
       (for [[y x] (nd/position-seq mat)
             :let [dx (- c x)
                   dy (- c y)
                   t  (Math/atan2 dy dx)
                   d  (Math/sqrt (* (+ 0.5 (* amp (Math/sin (* t spikes))))
                                    (+ (* dx dx) (* dy dy))))]]
         (nd/set-at mat x y (/ d dmax))))
      (contours/set-border2d mat 1)))

  (def res 128)
  (def width 640.0)
  (def scale (/ width (- res 2)))
  (def clipped (- width (* 2.0 scale)))
  (def n-scale 0.03)
  (def num-contours 60)

  (def palette
    (make-palette
     [0.5 0.5 0.5] [0.5 0.5 0.5] [1.0 1.0 1.0] [0 0.1 0.2]
     ;;[0.5 0.5 0.5] [0.5 0.5 0.5] [1.0 1.0 1.0] [0 1/3 2/3]
     ;;[0.5 0.5 0.5] [0.5 0.5 0.5] [1.0 1.0 0.5] [0.8 0.9 0.3]
     num-contours))

  (def mat (noise-matrix res n-scale))
  (def mat (circle-matrix res 8 0.25))

  (->> (m/norm-range num-contours)
       (rest)
       (map
        #(svg/group
          {:stroke (col/rgba->css (palette (int (* % (dec num-contours)))))
           :fill "none"}
          (map contour->svg (contours/find-contours2d mat %))))
       (svg/svg
        {:width width
         :height width
         :viewBox (format "%1.2f %1.2f %1.2f %1.2f" scale scale clipped clipped)})
       (svg/serialize)
       (spit "iso.svg"))
#+END_SRC

*** Implementation

Loosely based on Marching Squares/Cubes implementations by Paul Bourke (C) & Murphy Stein (Java):

- http://paulbourke.net/geometry/polygonise/
- https://github.com/murphydactyl/JavaKinectFingerTracker/blob/master/imageprocessor/FindIsolines.java

#+BEGIN_SRC clojure :noweb-ref contours2d
  (def edge-index
    [nil [2 0] [1 0] [1 0]
     [0 0] nil [0 0] [0 0]
     [3 0] [2 0] nil [1 0]
     [3 0] [2 0] [3 0] nil])

  (def next-edges
    [[-1 0] [0 1] [1 0] [0 -1]])

  (defn set-border2d
    [mat x]
    (let [[h w] (nd/shape mat)
          h' (dec h)
          w' (dec w)
          l  (nd/pick mat nil 0)
          r  (nd/pick mat nil w')
          t  (nd/pick mat 0 nil)
          b  (nd/pick mat h' nil)]
      (loop [i w']
        (when (>= i 0)
          (nd/set-at t i x)
          (nd/set-at b i x)
          (recur (dec i))))
      (loop [i h']
        (when (>= i 0)
          (nd/set-at l i x)
          (nd/set-at r i x)
          (recur (dec i))))
      mat))

  (defn encode-crossings2d
    [src isoval]
    (let [out  (nd/ndarray :int8 (byte-array (nd/size src)) (nd/shape src))
          iso? (fn [y x m] (if (< (nd/get-at src y x) isoval) m 0))]
      (loop [pos (nd/position-seq (nd/truncate-h src -1 -1))]
        (if pos
          (let [[y x] (first pos)
                x' (inc x)
                y' (inc y)]
            (nd/set-at
             out y x
             (-> (iso? y x 0x08)
                 (bit-or (iso? y  x' 0x04))
                 (bit-or (iso? y' x' 0x02))
                 (bit-or (iso? y' x  0x01))))
            (recur (next pos)))
          out))))

  (defn mean-cell-value2d
    [src y x]
    (* (+ (+ (nd/get-at src y x) (nd/get-at src y (inc x)))
          (+ (nd/get-at src (inc y) x) (nd/get-at src (inc y) (inc x))))
       0.25))

  (defn process-saddle5
    [src y x iso from]
    (if (> (mean-cell-value2d src y x) iso)
      (if (= 3 from) [2 0x04] [0 0x01])
      (if (= 3 from) [0 0x0d] [2 0x07])))

  (defn process-saddle10
    [src y x iso from]
    (if (> (mean-cell-value2d src y x) iso)
      (if (= 0 from) [3 0x02] [1 0x08])
      (if (= 2 from) [3 0x0b] [1 0x0e])))

  (defn process-cell2d
    [src code y x iso from]
    (case (int code)
      5 (process-saddle5 src y x iso from)
      10 (process-saddle10 src y x iso from)
      (edge-index (int code))))

  (defn mix2d
    [src y1 x1 y2 x2 iso]
    (let [a (nd/get-at src y1 x1)
          b (nd/get-at src y2 x2)]
      (if (== a b) 0 (/ (- a iso) (- a b)))))

  (defn contour-vertex2d
    [src y x to iso]
    (let [x' (inc x) y' (inc y)]
      (case (int to)
        0 [y (+ x (mix2d src y x y x' iso))]
        1 [(+ y (mix2d src y x' y' x' iso)) x']
        2 [y' (+ x (mix2d src y' x y' x' iso))]
        3 [(+ y (mix2d src y x y' x iso)) x]
        nil)))

  (defn find-contours2d
    [src isoval]
    (let [[h' w']  (map dec (nd/shape src))
          coded    (encode-crossings2d src isoval)
          contours (volatile! [])]
      (loop [pos  (nd/position-seq coded)
             curr []
             to   nil
             p    nil]
        (if pos
          (let [from to
                [y x] (if p p (first pos))]
            (if (or (>= x w') (>= y h'))
              (recur (next pos) curr to nil)
              (let [id         (nd/get-at coded y x)
                    [to clear] (process-cell2d src id y x isoval from)
                    curr       (if (and (nil? from) to (seq curr))
                                 (do (vswap! contours conj curr) [])
                                 curr)]
                (when clear
                  (nd/set-at coded y x clear))
                (if (and to (>= to 0))
                  (let [vertex  (contour-vertex2d src y x to isoval)
                        [oy ox] (next-edges to)]
                    (recur (next pos) (conj curr vertex) to [(+ y oy) (+ x ox)]))
                  (recur (next pos) curr to nil)))))
          (conj @contours curr)))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/ndarray/contours.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.ndarray.contours
    (:require
     [thi.ng.ndarray.core :as nd]))

  <<level-crossings>>

  <<contours2d>>
#+END_SRC


