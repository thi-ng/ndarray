#+SETUPFILE: setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingndarraycore][Namespace: thi.ng.ndarray.core]]
     - [[#protocols][Protocols]]
     - [[#ndarray-generator-macro][NDArray generator macro]]
     - [[#constructors][Constructors]]
     - [[#helper-functions][Helper functions]]
     - [[#complete-namespace-definitions][Complete namespace definitions]]

* Namespace: thi.ng.ndarray.core

** Protocols

#+BEGIN_SRC clojure :noweb-ref api
  (defprotocol PNDArray
    (data [_])
    (data-type [_])
    (dimension [_])
    (shape [_])
    (stride [_])
    (offset [_])
    (index-at [_ p])
    (index-pos [_ i])
    (get-at [_ p])
    (get-at-unsafe [_ p])
    (set-at [_ p v])
    (set-at-unsafe [_ p v])
    (hi [_ p])
    (lo [_ p])
    (transpose [_ p])
    (step [_ p])
    (pick [_ p]))
#+END_SRC

** NDArray generator macro

#+BEGIN_SRC clojure :noweb-ref macros
  (defn- make-symbols
    [id n] (mapv #(symbol (str id %)) (range n)))

  (defn- pair-fn
    [f coll]
    (let [coll (->> coll
                    (partition-all 2)
                    (map #(if (< 1 (count %)) (cons f %) (first %))))]
      (if (> (count coll) 2) (recur f coll) coll)))

  (defn- make-indexer
    [dim ->st p]
    `(+ ~@(->> (range dim)
               (map #(list '* (->st %) `(int (~p ~%))))
               (concat ['_offset])
               (pair-fn '+))))

  (defn- make-indexer-syms
    [dim ->st ->p]
    `(+ ~@(->> (range dim)
               (map #(list '* (->st %) (->p %)))
               (concat ['_offset])
               (pair-fn '+))))

  (defn- with-bounds-check
    [dim psyms shapes clj? & body]
    `(if (and
          ~@(mapcat
             #(list `(>= ~(symbol (psyms %)) 0)
                    `(< ~(symbol (psyms %)) ~(symbol (shapes %))))
             (range dim)))
       (do ~@body)
       (throw
        (new ~(if clj? 'IndexOutOfBoundsException 'js/Error)
             (str "Invalid index: " (pr-str [~@psyms]))))))

  (defn- inject-clj-protos
    [clj? get ->a ->sh idx rdim]
    (if clj?
      (list
       'clojure.lang.Seqable
       `(~'seq
         [_#]
         (for [~@(mapcat #(vector (->a %) `(range ~(->sh %))) rdim)]
           (~get ~'_data ~idx))))
      (list
       'ISeqable
       `(~'-seq
         [_#]
         (for [~@(mapcat #(vector (->a %) `(range ~(->sh %))) rdim)]
           (~get ~'_data ~idx))))))

  (defn type-hinted
    [cast type x] (if cast (with-meta x {:tag (name type)}) x))

  (defmacro def-ndarray
    [dim cast type-hint data-ctor get set & [clj?]]
    (let [type-name (symbol (str "NDArray" dim (name type-hint)))
          raw-name  (symbol (str "make-raw-ndarray" dim "-" (name type-hint)))
          strides   (make-symbols "_stride" dim)
          shapes    (make-symbols "_shape" dim)
          asyms     (make-symbols "a" dim)
          bsyms     (make-symbols "b" dim)
          psyms     (make-symbols "p" dim)
          [->st ->sh ->a ->b ->p] (map #(comp symbol %) [strides shapes asyms bsyms psyms])
          [c d p o] (repeatedly gensym)
          idx       (make-indexer dim ->st p)
          idx-syms  (make-indexer-syms dim ->st ->p)
          rdim      (range dim)]
      `(do
         (deftype ~type-name
             [~(if cast (with-meta '_data {:tag (name type-hint)}) '_data)
              ~'_offset ~@strides ~@shapes]
           ~@(inject-clj-protos clj? get ->a ->sh (make-indexer-syms dim ->st ->a) rdim)
           ~'PNDArray
           (~'data
             [_#] ~'_data)
           (~'data-type
             [_#] ~type-hint)
           (~'dimension
             [_#] ~dim)
           (~'stride
             [_#] [~@strides])
           (~'shape
             [_#] [~@shapes])
           (~'offset
             [_#] ~'_offset)
           (~'index-at
             [_# ~p] ~idx)
           (~'index-pos
             [_# ~p]
             (let [~p (int ~p)
                   ~c (- ~p ~'_offset)
                   ~@(mapcat
                      #(list
                        (->a %) `(int (/ ~c ~(->st %)))
                        c `(- ~c (* ~(->a %) ~(->st %))))
                      rdim)]
               [~@asyms]))
           (~'get-at
             [_# [~@psyms]]
             ~(with-bounds-check dim psyms shapes clj?
                `(~get ~(type-hinted cast type-hint '_data) (int ~idx-syms))))
           (~'get-at-unsafe
             [_# ~p] (~get ~(type-hinted cast type-hint '_data) (int ~idx)))
           (~'set-at
             [_# [~@psyms] ~c]
             ~(with-bounds-check dim psyms shapes clj?
                `(~set ~(type-hinted cast type-hint '_data) (int ~idx-syms) ~(if cast `(~cast ~c) c)))
             _#)
           (~'set-at-unsafe
             [_# ~p ~c] (~set ~(type-hinted cast type-hint '_data) (int ~idx) ~(if cast `(~cast ~c) c)) _#)
           (~'hi
             [_# [~@psyms]]
             (new ~type-name ~'_data ~'_offset ~@strides
                  ~@(map
                     #(list 'if `(neg? ~(->p %)) (->sh %) `(int ~(->p %)))
                     rdim)))
           (~'lo
             [_# [~@psyms]]
             (let [~@(mapcat
                      #(list
                        [(->a %) (->b %)]
                        `(if (pos? ~(->p %))
                           [(- ~(->sh %) (int ~(->p %)))
                            (* ~(->st %) (int ~(->p %)))]
                           [~(->sh %) 0]))
                      rdim)
                   ~o (+ ~@(->> rdim (map ->b) (cons '_offset) (pair-fn '+)))]
               (new ~type-name ~'_data ~o ~@strides ~@asyms)))
           (~'transpose
             [_# [~@psyms]]
             (let [~@(mapcat #(list (->p %) `(if ~(->p %) (int ~(->p %)) ~%)) rdim)
                   ~c [~@strides]
                   ~d [~@shapes]]
               (new ~type-name ~'_data ~'_offset
                    ~@(map #(list c (->p %)) rdim)
                    ~@(map #(list d (->p %)) rdim))))
           (~'step
             [_# [~@psyms]]
             (let [~o ~'_offset
                   ~@(mapcat
                      #(let [stride' `(* ~(->st %) (int ~(->p %)))]
                         (list
                          [(->a %) (->b %) o]
                          `(if (number? ~(->p %))
                             (if (neg? ~(->p %))
                               [~(list 'int (list 'Math/ceil `(/ (- ~(->sh %)) (int ~(->p %)))))
                                ~stride'
                                (+ ~o (* ~(->st %) (dec ~(->sh %))))]
                               [~(list 'int (list 'Math/ceil `(/ ~(->sh %) (int ~(->p %)))))
                                ~stride'
                                ~o])
                             [~(->sh %) ~(->st %) ~o])))
                      rdim)]
               (new ~type-name ~'_data ~o ~@bsyms ~@asyms)))
           (~'pick
             [_# [~@psyms]]
             (let [~o ~'_offset, ~c [], ~d []
                   ~@(mapcat
                      #(list
                        [c d o]
                        `(if (and (number? ~(->p %)) (>= ~(->p %) 0))
                           [~c ~d (+ ~o (* ~(->st %) (int ~(->p %))))]
                           [(conj ~c ~(->sh %)) (conj ~d ~(->st %)) ~o]))
                      rdim)
                   cnt# (count ~c)]
               (if (pos? cnt#)
                 ((get-in @~'ctor-registry [cnt# ~type-hint :ctor]) ~'_data ~o ~d ~c)
                 (~get ~(type-hinted cast type-hint '_data) ~o))))
           ~'Object
           (~'toString
             [_#]
             (pr-str
              {:data ~'_data :type ~type-hint
               :size (* ~@shapes) :total (count ~'_data) :offset ~'_offset
               :shape [~@shapes] :stride [~@strides]})))

         (defn ~(with-meta raw-name {:export true})
           [data# o# [~@strides] [~@shapes]]
           (new ~type-name data# o# ~@strides ~@shapes))

         ;;(prn :ndarray ~dim ~type-hint ~type-name ~raw-name)

         (swap!
          ~'thi.ng.ndarray.core/ctor-registry
          assoc-in [~dim ~type-hint]
          {:ctor ~raw-name
           :data-ctor ~data-ctor}))))
#+END_SRC

** Constructors

#+BEGIN_SRC clojure :noweb-ref ctors
  (def ctor-registry (atom {}))

  #?(:clj
     (do
       (def-ndarray 1 nil :generic to-array aget aset true)
       (def-ndarray 1 boolean :booleans boolean-array aget aset-boolean true)
       (def-ndarray 1 byte :bytes byte-array aget aset-byte true)
       (def-ndarray 1 short :shorts short-array aget aset-short true)
       (def-ndarray 1 int :ints int-array aget aset-int true)
       (def-ndarray 1 long :longs long-array aget aset-long true)
       (def-ndarray 1 float :floats float-array aget aset-float true)
       (def-ndarray 1 double :doubles double-array aget aset-double true)

       (def-ndarray 2 nil :generic to-array aget aset true)
       (def-ndarray 2 boolean :booleans boolean-array aget aset-boolean true)
       (def-ndarray 2 byte :bytes byte-array aget aset-byte true)
       (def-ndarray 2 short :shorts short-array aget aset-short true)
       (def-ndarray 2 int :ints int-array aget aset-int true)
       (def-ndarray 2 long :longs long-array aget aset-long true)
       (def-ndarray 2 float :floats float-array aget aset-float true)
       (def-ndarray 2 double :doubles double-array aget aset-double true)

       (def-ndarray 3 nil :generic to-array aget aset true)
       (def-ndarray 3 boolean :booleans boolean-array aget aset-boolean true)
       (def-ndarray 3 byte :bytes byte-array aget aset-byte true)
       (def-ndarray 3 short :shorts short-array aget aset-short true)
       (def-ndarray 3 int :ints int-array aget aset-int true)
       (def-ndarray 3 long :longs long-array aget aset-long true)
       (def-ndarray 3 float :floats float-array aget aset-float true)
       (def-ndarray 3 double :doubles double-array aget aset-double true)

       (def-ndarray 4 nil :generic to-array aget aset true)
       (def-ndarray 4 boolean :booleans boolean-array aget aset-boolean true)
       (def-ndarray 4 byte :bytes byte-array aget aset-byte true)
       (def-ndarray 4 short :shorts short-array aget aset-short true)
       (def-ndarray 4 int :ints int-array aget aset-int true)
       (def-ndarray 4 long :longs long-array aget aset-long true)
       (def-ndarray 4 float :floats float-array aget aset-float true)
       (def-ndarray 4 double :doubles double-array aget aset-double true)
       )
     :cljs
     (do
       (def-ndarray 1 nil :generic to-array aget aset false)
       (def-ndarray 1 nil :uint8 a/uint8 aget aset false)
       (def-ndarray 1 nil :uint8-clamped a/uint8-clamped aget aset false)
       (def-ndarray 1 nil :uint16 a/uint16 aget aset false)
       (def-ndarray 1 nil :uint32 a/uint32 aget aset false)
       (def-ndarray 1 nil :int8 a/int8 aget aset false)
       (def-ndarray 1 nil :int16 a/int16 aget aset false)
       (def-ndarray 1 nil :int32 a/int32 aget aset false)
       (def-ndarray 1 nil :float32 a/float32 aget aset false)
       (def-ndarray 1 nil :float64 a/float64 aget aset false)

       (def-ndarray 2 nil :generic to-array aget aset false)
       (def-ndarray 2 nil :uint8 a/uint8 aget aset false)
       (def-ndarray 2 nil :uint8-clamped a/uint8-clamped aget aset false)
       (def-ndarray 2 nil :uint16 a/uint16 aget aset false)
       (def-ndarray 2 nil :uint32 a/uint32 aget aset false)
       (def-ndarray 2 nil :int8 a/int8 aget aset false)
       (def-ndarray 2 nil :int16 a/int16 aget aset false)
       (def-ndarray 2 nil :int32 a/int32 aget aset false)
       (def-ndarray 2 nil :float32 a/float32 aget aset false)
       (def-ndarray 2 nil :float64 a/float64 aget aset false)

       (def-ndarray 3 nil :generic to-array aget aset false)
       (def-ndarray 3 nil :uint8 a/uint8 aget aset false)
       (def-ndarray 3 nil :uint8-clamped a/uint8-clamped aget aset false)
       (def-ndarray 3 nil :uint16 a/uint16 aget aset false)
       (def-ndarray 3 nil :uint32 a/uint32 aget aset false)
       (def-ndarray 3 nil :int8 a/int8 aget aset false)
       (def-ndarray 3 nil :int16 a/int16 aget aset false)
       (def-ndarray 3 nil :int32 a/int32 aget aset false)
       (def-ndarray 3 nil :float32 a/float32 aget aset false)
       (def-ndarray 3 nil :float64 a/float64 aget aset false)

       (def-ndarray 4 nil :generic to-array aget aset false)
       (def-ndarray 4 nil :uint8 a/uint8 aget aset false)
       (def-ndarray 4 nil :uint8-clamped a/uint8-clamped aget aset false)
       (def-ndarray 4 nil :uint16 a/uint16 aget aset false)
       (def-ndarray 4 nil :uint32 a/uint32 aget aset false)
       (def-ndarray 4 nil :int8 a/int8 aget aset false)
       (def-ndarray 4 nil :int16 a/int16 aget aset false)
       (def-ndarray 4 nil :int32 a/int32 aget aset false)
       (def-ndarray 4 nil :float32 a/float32 aget aset false)
       (def-ndarray 4 nil :float64 a/float64 aget aset false)
       ))

  (defn ndarray
    ([data shape]
     (ndarray ::generic data shape))
    ([type data shape]
     (let [{:keys [ctor data-ctor]} (get-in @ctor-registry [(count shape) type])]
       (if ctor
         (ctor (if (sequential? data) (data-ctor data) data) 0 (shape->stride shape) shape)
         (throw (new #?(:clj IllegalArgumentException :cljs js/Error)
                     (str "Can't create ndarray for: " type " " data)))))))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref ops
  (defn order
    [coll] (->> coll (map vector (range)) (sort-by peek) (mapv first)))

  (defn shape->stride
    [shape]
    (->> shape
         reverse
         (reduce #(conj % (* %2 (first %))) '(1))
         (drop 1)
         (vec)))
#+END_SRC

** Complete namespace definitions

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/ndarray/core.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.ndarray.core
    #?@(:clj
        [(:require
          [thi.ng.ndarray.macros :refer [def-ndarray]])]
        :cljs
        [(:require-macros
          [thi.ng.ndarray.macros :refer [def-ndarray]])
         (:require
          [thi.ng.typedarrays.core :as a])]))

  <<api>>

  <<ops>>

  <<ctors>>
#+END_SRC

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/ndarray/macros.clj :noweb yes :mkdirp yes :padline no
  (ns thi.ng.ndarray.macros)

  <<macros>>
#+END_SRC
