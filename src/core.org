#+SETUPFILE: setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thingndarraycore][Namespace: thi.ng.ndarray.core]]
     - [[#protocols][Protocols]]
     - [[#ndarray-generator-macro][NDArray generator macro]]
     - [[#constructors][Constructors]]
     - [[#helper-functions][Helper functions]]
     - [[#complete-namespace-definitions][Complete namespace definitions]]

* Namespace: thi.ng.ndarray.core

** Protocols

#+BEGIN_SRC clojure :noweb-ref api
  (defprotocol PNDArray
    (data [_]
      "Returns the backing data array")
    (data-type [_]
      "Returns the ndarray's type id (keyword)")
    (dimension [_]
      "Returns the ndarray's dimension")
    (shape [_]
      "Returns a vector of the ndarray's sizes in each dimension")
    (stride [_]
      "Returns a vector of the ndarray's stride in each dimension")
    (offset [_]
      "Returns the ndarray's start index in the backing data array")
    (index-at [_ p]
      "Returns the index into the backing array for given position in
      this ndarray view")
    (index-pos [_ i]
      "Computes position in this ndarray view from given array index")
    (index-seq [_]
      "Returns a lazy seq of all array indices in a ndarray view")
    (position-seq [_]
      "Returns a lazy seq of all position vectors in a ndarray view")
    (get-at [_ p]
      "Returns value at given position (without bounds check,
      assumes position is safe)")
    (get-at-safe [_ p]
      "Returns value at given position (with bounds check)")
    (get-at-index [_ i])
    (set-at [_ p v]
      "Sets value in backing data array at given position
      (without bounds check). Returns same NDArray instance.")
    (set-at-safe [_ p v]
      "Sets value in backing data array at given position (with bounds
      check). Returns same NDArray instance.")
    (set-at-index [_ i v])
    (update-at [_ p f])
    (update-at-safe [_ p f])
    (update-at-index [_ i f])
    (hi [_ p]
      "Returns a new ndarray of same type with its shape truncated at
      top end")
    (lo [_ p]
      "Returns a new ndarray of same type with its shape truncated at
      lower end, effectively shifting its start index/offset.")
    (transpose [_ t]
      "Returns new ndarray view with stride order/axes swapped as per
      given vector.")
    (step [_ p]
      "Returns new ndarray view with stride steps/direction changed as
      per given vector. Values >1 result in skipping items, negative
      value flip direction, `nil` keeps current stride for that
      dimension.")
    (pick [_ p]
      "Accepts a vector of n-values, each selecting a slice of
      dimension (nil skips a dimension). Returns new ndarray view of
      selection, or if selecting in all dimensions, returns array value
      at that point."))
#+END_SRC

** NDArray generator macro

#+BEGIN_SRC clojure :noweb-ref macros
  (defn- make-symbols
    [id n] (mapv #(symbol (str id %)) (range n)))

  (defn- pair-fn
    [f coll]
    (let [coll (->> coll
                    (partition-all 2)
                    (map #(if (< 1 (count %)) (cons f %) (first %))))]
      (if (> (count coll) 2) (recur f coll) coll)))

  (defn- make-indexer
    [dim ->st p]
    `(+ ~@(->> (range dim)
               (map #(list '* (->st %) `(int (~p ~%))))
               (concat ['_offset])
               (pair-fn '+))))

  (defn- make-indexer-syms
    [dim ->st ->p]
    `(+ ~@(->> (range dim)
               (map #(list '* (->st %) (->p %)))
               (concat ['_offset])
               (pair-fn '+))))

  (defn- with-bounds-check
    [dim psyms shapes clj? & body]
    `(if (and
          ~@(mapcat
             #(list `(>= ~(symbol (psyms %)) 0)
                    `(< ~(symbol (psyms %)) ~(symbol (shapes %))))
             (range dim)))
       (do ~@body)
       (throw
        (new ~(if clj? 'IndexOutOfBoundsException 'js/Error)
             (str "Invalid index: " (pr-str [~@psyms]))))))

  (defn- inject-clj-protos
    [clj? get ->a ->sh idx rdim]
    (if clj?
      (list
       'clojure.lang.Seqable
       `(~'seq
         [_#]
         (for [~@(mapcat #(vector (->a %) `(range ~(->sh %))) rdim)]
           (~get ~'_data ~idx))))
      (list
       'ISeqable
       `(~'-seq
         [_#]
         (for [~@(mapcat #(vector (->a %) `(range ~(->sh %))) rdim)]
           (~get ~'_data ~idx))))))

  (defn type-hinted
    [type x] (if type (with-meta x {:tag (name type)}) x))

  (defmacro def-ndarray
    [dim cast type-hint type-id data-ctor get set & [clj?]]
    (let [type-name (symbol (str "NDArray" dim (name type-id)))
          raw-name  (symbol (str "make-raw-ndarray" dim "-" (name type-id)))
          strides   (make-symbols "_stride" dim)
          shapes    (make-symbols "_shape" dim)
          asyms     (make-symbols "a" dim)
          bsyms     (make-symbols "b" dim)
          psyms     (make-symbols "p" dim)
          [->st ->sh ->a ->b ->p] (map #(comp symbol %) [strides shapes asyms bsyms psyms])
          [c d f p o] (repeatedly gensym)
          idx       (make-indexer dim ->st p)
          idx-syms  (make-indexer-syms dim ->st ->p)
          rdim      (range dim)]
      `(do
         (deftype ~type-name
             [~(type-hinted type-hint '_data) ~'_offset ~@strides ~@shapes]
           ~@(inject-clj-protos clj? get ->a ->sh (make-indexer-syms dim ->st ->a) rdim)
           ~'PNDArray
           (~'data
             [_#] ~'_data)
           (~'data-type
             [_#] ~type-id)
           (~'dimension
             [_#] ~dim)
           (~'stride
             [_#] [~@strides])
           (~'shape
             [_#] [~@shapes])
           (~'offset
             [_#] ~'_offset)
           (~'index-at
             [_# ~p] ~idx)
           (~'index-pos
             [_# ~p]
             (let [~p (int ~p)
                   ~c (- ~p ~'_offset)
                   ~@(mapcat
                      #(list
                        (->a %) `(int (/ ~c ~(->st %)))
                        c `(- ~c (* ~(->a %) ~(->st %))))
                      rdim)]
               [~@asyms]))
           (~'index-seq
             [_#]
             (for [~@(mapcat #(vector (->a %) `(range ~(->sh %))) rdim)]
               ~(make-indexer-syms dim ->st ->a)))
           (~'position-seq
             [_#]
             (for [~@(mapcat #(vector (->a %) `(range ~(->sh %))) rdim)]
               [~@asyms]))
           (~'get-at
             [_# ~p]
             (~get ~(type-hinted type-hint '_data) (int ~idx)))
           (~'get-at-safe
             [_# [~@psyms]]
             ~(with-bounds-check dim psyms shapes clj?
                `(~get ~(type-hinted type-hint '_data) (int ~idx-syms))))
           (~'get-at-index
             [_# i#]
             (~get ~(type-hinted type-hint '_data) (int i#)))
           (~'set-at
             [_# ~p ~c]
             (~set ~(type-hinted type-hint '_data) (int ~idx) ~(if cast `(~cast ~c) c)) _#)
           (~'set-at-safe
             [_# [~@psyms] ~c]
             ~(with-bounds-check dim psyms shapes clj?
                `(~set ~(type-hinted type-hint '_data) (int ~idx-syms) ~(if cast `(~cast ~c) c)))
             _#)
           (~'set-at-index
             [_# i# ~c]
             (~set ~(type-hinted type-hint '_data) (int i#) ~(if cast `(~cast ~c) c)) _#)
           (~'update-at
             [_# ~p ~f]
             (let [~c (int ~idx)]
               (~set ~(type-hinted type-hint '_data) ~c
                     ~(if cast
                        `(~cast (~f ~p (~get ~(type-hinted type-hint '_data) ~c)))
                        `(~f ~c (~get ~(type-hinted type-hint '_data) ~c)))))
             _#)
           (~'update-at-safe
             [_# [~@psyms :as ~p] ~f]
             ~(with-bounds-check dim psyms shapes clj?
                `(let [~c (int ~idx-syms)]
                   (~set ~(type-hinted type-hint '_data) ~c
                         ~(if cast
                            `(~cast (~f ~p (~get ~(type-hinted type-hint '_data) ~c)))
                            `(~f ~c (~get ~(type-hinted type-hint '_data) ~c))))))
             _#)
           (~'update-at-index
             [_# ~c ~f]
             (~set ~(type-hinted type-hint '_data) ~c
                   ~(if cast
                      `(~cast (~f ~c (~get ~(type-hinted type-hint '_data) ~c)))
                      `(~f ~c (~get ~(type-hinted type-hint '_data) ~c))))
             _#)
           (~'hi
             [_# [~@psyms]]
             (new ~type-name ~'_data ~'_offset ~@strides
                  ~@(map
                     #(list 'if `(neg? ~(->p %)) (->sh %) `(int ~(->p %)))
                     rdim)))
           (~'lo
             [_# [~@psyms]]
             (let [~@(mapcat
                      #(list
                        [(->a %) (->b %)]
                        `(if (pos? ~(->p %))
                           [(- ~(->sh %) (int ~(->p %)))
                            (* ~(->st %) (int ~(->p %)))]
                           [~(->sh %) 0]))
                      rdim)
                   ~o (+ ~@(->> rdim (map ->b) (cons '_offset) (pair-fn '+)))]
               (new ~type-name ~'_data ~o ~@strides ~@asyms)))
           (~'transpose
             [_# [~@psyms]]
             (let [~@(mapcat #(list (->p %) `(if ~(->p %) (int ~(->p %)) ~%)) rdim)
                   ~c [~@strides]
                   ~d [~@shapes]]
               (new ~type-name ~'_data ~'_offset
                    ~@(map #(list c (->p %)) rdim)
                    ~@(map #(list d (->p %)) rdim))))
           (~'step
             [_# [~@psyms]]
             (let [~o ~'_offset
                   ~@(mapcat
                      #(let [stride' `(* ~(->st %) (int ~(->p %)))]
                         (list
                          [(->a %) (->b %) o]
                          `(if (number? ~(->p %))
                             (if (neg? ~(->p %))
                               [~(list 'int (list 'Math/ceil `(/ (- ~(->sh %)) (int ~(->p %)))))
                                ~stride'
                                (+ ~o (* ~(->st %) (dec ~(->sh %))))]
                               [~(list 'int (list 'Math/ceil `(/ ~(->sh %) (int ~(->p %)))))
                                ~stride'
                                ~o])
                             [~(->sh %) ~(->st %) ~o])))
                      rdim)]
               (new ~type-name ~'_data ~o ~@bsyms ~@asyms)))
           (~'pick
             [_# [~@psyms]]
             (let [~o ~'_offset, ~c [], ~d []
                   ~@(mapcat
                      #(list
                        [c d o]
                        `(if (and (number? ~(->p %)) (>= ~(->p %) 0))
                           [~c ~d (+ ~o (* ~(->st %) (int ~(->p %))))]
                           [(conj ~c ~(->sh %)) (conj ~d ~(->st %)) ~o]))
                      rdim)
                   cnt# (count ~c)]
               (if (pos? cnt#)
                 ((get-in @~'ctor-registry [cnt# ~type-id :ctor]) ~'_data ~o ~d ~c)
                 (~get ~(type-hinted type-hint '_data) ~o))))
           ~'Object
           (~'toString
             [_#]
             (pr-str
              {:data ~'_data :type ~type-id
               :size (* ~@shapes) :total (count ~'_data) :offset ~'_offset
               :shape [~@shapes] :stride [~@strides]})))

         (defn ~(with-meta raw-name {:export true})
           [data# o# [~@strides] [~@shapes]]
           (new ~type-name data# o# ~@strides ~@shapes))

         (swap!
          ~'thi.ng.ndarray.core/ctor-registry
          assoc-in [~dim ~type-id]
          {:ctor ~raw-name
           :data-ctor ~data-ctor}))))
#+END_SRC

** Constructors

#+BEGIN_SRC clojure :noweb-ref ctors
  (def ctor-registry (atom {}))

  #?(:clj
     (do
       (def-ndarray 1 nil     nil        :generic to-array aget aset true)
       (def-ndarray 1 boolean "booleans" :boolean boolean-array aget aset-boolean true)
       (def-ndarray 1 byte    "bytes"    :int8    byte-array aget aset-byte true)
       (def-ndarray 1 short   "shorts"   :int16   short-array aget aset-short true)
       (def-ndarray 1 int     "ints"     :int32   int-array aget aset-int true)
       (def-ndarray 1 long    "longs"    :int64   long-array aget aset-long true)
       (def-ndarray 1 float   "floats"   :float32 float-array aget aset-float true)
       (def-ndarray 1 double  "doubles"  :float64 double-array aget aset-double true)

       (def-ndarray 2 nil     nil        :generic to-array aget aset true)
       (def-ndarray 2 boolean "booleans" :boolean boolean-array aget aset-boolean true)
       (def-ndarray 2 byte    "bytes"    :int8    byte-array aget aset-byte true)
       (def-ndarray 2 short   "shorts"   :int26   short-array aget aset-short true)
       (def-ndarray 2 int     "ints"     :int32   int-array aget aset-int true)
       (def-ndarray 2 long    "longs"    :int64   long-array aget aset-long true)
       (def-ndarray 2 float   "floats"   :float32 float-array aget aset-float true)
       (def-ndarray 2 double  "doubles"  :float64 double-array aget aset-double true)

       (def-ndarray 3 nil     nil        :generic to-array aget aset true)
       (def-ndarray 3 boolean "booleans" :boolean boolean-array aget aset-boolean true)
       (def-ndarray 3 byte    "bytes"    :int8    byte-array aget aset-byte true)
       (def-ndarray 3 short   "shorts"   :int36   short-array aget aset-short true)
       (def-ndarray 3 int     "ints"     :int32   int-array aget aset-int true)
       (def-ndarray 3 long    "longs"    :int64   long-array aget aset-long true)
       (def-ndarray 3 float   "floats"   :float32 float-array aget aset-float true)
       (def-ndarray 3 double  "doubles"  :float64 double-array aget aset-double true)

       (def-ndarray 4 nil     nil        :generic to-array aget aset true)
       (def-ndarray 4 boolean "booleans" :boolean boolean-array aget aset-boolean true)
       (def-ndarray 4 byte    "bytes"    :int8    byte-array aget aset-byte true)
       (def-ndarray 4 short   "shorts"   :int46   short-array aget aset-short true)
       (def-ndarray 4 int     "ints"     :int32   int-array aget aset-int true)
       (def-ndarray 4 long    "longs"    :int64   long-array aget aset-long true)
       (def-ndarray 4 float   "floats"   :float32 float-array aget aset-float true)
       (def-ndarray 4 double  "doubles"  :float64 double-array aget aset-double true)
       )
     :cljs
     (do
       (def-ndarray 1 nil nil :generic to-array aget aset false)
       (def-ndarray 1 nil nil :uint8 a/uint8 aget aset false)
       (def-ndarray 1 nil nil :uint8-clamped a/uint8-clamped aget aset false)
       (def-ndarray 1 nil nil :uint16 a/uint16 aget aset false)
       (def-ndarray 1 nil nil :uint32 a/uint32 aget aset false)
       (def-ndarray 1 nil nil :int8 a/int8 aget aset false)
       (def-ndarray 1 nil nil :int16 a/int16 aget aset false)
       (def-ndarray 1 nil nil :int32 a/int32 aget aset false)
       (def-ndarray 1 nil nil :float32 a/float32 aget aset false)
       (def-ndarray 1 nil nil :float64 a/float64 aget aset false)

       (def-ndarray 2 nil nil :generic to-array aget aset false)
       (def-ndarray 2 nil nil :uint8 a/uint8 aget aset false)
       (def-ndarray 2 nil nil :uint8-clamped a/uint8-clamped aget aset false)
       (def-ndarray 2 nil nil :uint16 a/uint16 aget aset false)
       (def-ndarray 2 nil nil :uint32 a/uint32 aget aset false)
       (def-ndarray 2 nil nil :int8 a/int8 aget aset false)
       (def-ndarray 2 nil nil :int16 a/int16 aget aset false)
       (def-ndarray 2 nil nil :int32 a/int32 aget aset false)
       (def-ndarray 2 nil nil :float32 a/float32 aget aset false)
       (def-ndarray 2 nil nil :float64 a/float64 aget aset false)

       (def-ndarray 3 nil nil :generic to-array aget aset false)
       (def-ndarray 3 nil nil :uint8 a/uint8 aget aset false)
       (def-ndarray 3 nil nil :uint8-clamped a/uint8-clamped aget aset false)
       (def-ndarray 3 nil nil :uint16 a/uint16 aget aset false)
       (def-ndarray 3 nil nil :uint32 a/uint32 aget aset false)
       (def-ndarray 3 nil nil :int8 a/int8 aget aset false)
       (def-ndarray 3 nil nil :int16 a/int16 aget aset false)
       (def-ndarray 3 nil nil :int32 a/int32 aget aset false)
       (def-ndarray 3 nil nil :float32 a/float32 aget aset false)
       (def-ndarray 3 nil nil :float64 a/float64 aget aset false)

       (def-ndarray 4 nil nil :generic to-array aget aset false)
       (def-ndarray 4 nil nil :uint8 a/uint8 aget aset false)
       (def-ndarray 4 nil nil :uint8-clamped a/uint8-clamped aget aset false)
       (def-ndarray 4 nil nil :uint16 a/uint16 aget aset false)
       (def-ndarray 4 nil nil :uint32 a/uint32 aget aset false)
       (def-ndarray 4 nil nil :int8 a/int8 aget aset false)
       (def-ndarray 4 nil nil :int16 a/int16 aget aset false)
       (def-ndarray 4 nil nil :int32 a/int32 aget aset false)
       (def-ndarray 4 nil nil :float32 a/float32 aget aset false)
       (def-ndarray 4 nil nil :float64 a/float64 aget aset false)
       ))

  (defn ndarray
    ([data shape]
     (ndarray ::generic data shape))
    ([type data shape]
     (let [{:keys [ctor data-ctor]} (get-in @ctor-registry [(count shape) type])]
       (if ctor
         (ctor (if (sequential? data) (data-ctor data) data) 0 (shape->stride shape) shape)
         (throw (new #?(:clj IllegalArgumentException :cljs js/Error)
                     (str "Can't create ndarray for: " type " " data)))))))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref ops
  (defn order
    [coll] (->> coll (map vector (range)) (sort-by peek) (mapv first)))

  (defn shape->stride
    [shape]
    (->> shape
         reverse
         (reduce #(conj % (* %2 (first %))) '(1))
         (drop 1)
         (vec)))
#+END_SRC

** Complete namespace definitions

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/ndarray/core.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.ndarray.core
    #?@(:clj
        [(:require
          [thi.ng.ndarray.macros :refer [def-ndarray]])]
        :cljs
        [(:require-macros
          [thi.ng.ndarray.macros :refer [def-ndarray]])
         (:require
          [thi.ng.typedarrays.core :as a])]))

  <<api>>

  <<ops>>

  <<ctors>>
#+END_SRC

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/ndarray/macros.clj :noweb yes :mkdirp yes :padline no
  (ns thi.ng.ndarray.macros)

  <<macros>>
#+END_SRC
